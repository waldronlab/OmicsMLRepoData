---
title: "Harmonize disease/age/bodysite information in cMD sample metadata"
author: "Sehyun Oh"
date: "`r format(Sys.time(), '%B %d, %Y')`"
format:
    html:
        fontsize: 14px
        toc: true
        top-depth: 3
abstract: "Prepare U24 Supplement: AI/ML-ready"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, 
                      collapse = TRUE, eval = FALSE)
```

# Load Packages 
```{r}
suppressPackageStartupMessages({
    library(gsheet)
    library(dplyr)
    library(RCurl) # for getURL
    library(curatedMetagenomicData)
    library(OmicsMLRepoData)
    library(readr)
    library(tidyr)
    library(yaml)
    library(googlesheets4)
    library(tidyverse)
    library(plyr)
    library(rols)
})
```

```{r echo=FALSE}
## Add the `curation_id` column
proj_dir <- "~/Packages/OmicsMLRepoData/curatedMetagenomicData/"
sampleMetadata$curation_id <- paste(sampleMetadata$study_name,
                                    sampleMetadata$sample_id,
                                    sep = ":")

## Google Sheet connection
url <- "https://docs.google.com/spreadsheets/d/1QSbB_b1DkfqOc7q5eHE0IDHSiGqNUyTE8d4GzbSEzjM/edit?usp=sharing"
ss <- googledrive::as_id(url)
```

# Disease 
Manual curation efforts for curatedMetagenomicData `sampleMetadata` are 
happening in a several GitHub repositories. We will first collect the most
up-to-date versions of them. For 'disease' curation, data inputs include: 

1. Curated metagenomic data curation tables ([link](https://github.com/waldronlab/curatedMetagenomicDataCuration/tree/master/inst/extdata)) 
2. Hand-curated disease ontology table ([link](https://github.com/Ethan-Loo/Bioinformatics_Data_Curation_Collaboration)) 
3. Our curation work under OmicsMLRepoData GitHub repo.

## Sources
### curatedMetagenomicDataCuration
```{r}
file_url <- "https://raw.githubusercontent.com/waldronlab/curatedMetagenomicDataCuration/master/inst/extdata/updated-disease-ontology.csv"
cmd_disease <- read.csv(file_url, sep = ",", header = TRUE)
head(cmd_disease, 3)
```

### Disease ontology curation
```{r}
file_url <- "https://raw.githubusercontent.com/Ethan-Loo/Bioinformatics_Data_Curation_Collaboration/main/disease_ontology.yaml"
x <- yaml::yaml.load_file(file_url)
disease_ontology <- as.data.frame(do.call(rbind, x)) %>%
    tibble::rownames_to_column(., "Original.Abbreviation.Name")

colnames(disease_ontology)[2:3] <- c("Full.Name", "Ontology.link")
disease_ontology$Full.Name <- as.character(disease_ontology$Full.Name)
disease_ontology$Ontology.link <- as.character(disease_ontology$Ontology.link)

head(disease_ontology, 3)
```

### OmicsMLRepo
This is currently stored under the private repo.
```{r}
## Our curation file
file_url <- "https://raw.githubusercontent.com/waldronlab/OmicsMLRepoData/master/curatedMetagenomicData/maps/cMD_condition_ontology.csv?token=GHSAT0AAAAAAB7ODWEIMK4WXDXWGC3BTVDIZATQQKA"
mlRepo_disease_all <- read.csv(file_url, sep = ",", header = TRUE)
head(mlRepo_disease_all, 3)

colnames(mlRepo_disease) <- c("Original.Abbreviation.Name",
                              "Full.Name",
                              "Ontology.link") # To merge with the other tables
```

### sampleMetadata
This is the target metadata file to be updated through our curation.
```{r}
file_url <- "https://github.com/waldronlab/curatedMetagenomicData/raw/master/data/sampleMetadata.rda"
download.file(file_url, "sampleMetadata.rda")
load("sampleMetadata.rda")
```

#### Duplicated samples
FYI, there are duplicated samples in cMD, so need to be careful when we split
and merge metadata table during the harmonization process.

```{r}
table(is.na(sampleMetadata$age), is.na(sampleMetadata$infant_age))

## There are duplicated samples
apply(sampleMetadata, 2, function(x) {length(unique(x))}) %>% 
    sort(decreasing = TRUE) %>% 
    head

dup_samples <- sampleMetadata$sample_id[duplicated(sampleMetadata$sample_id)]
dup_samples_tb <- sampleMetadata %>% filter(sample_id %in% dup_samples)
table(dup_samples_tb$study_name)
```

To handle these duplicated samples, we provide `curation_id` which is the 
combination of study name and sample id (`study_name:sample_id`).
```{r eval=FALSE}
sampleMetadata$curation_id <- paste(sampleMetadata$study_name,
                                    sampleMetadata$sample_id,
                                    sep = ":")
```


#### Columns to be merged
```{r}
colnames(sampleMetadata)[grep("disease", colnames(sampleMetadata))]
colnames(sampleMetadata)[grep("condition", colnames(sampleMetadata))]
```

```{r}
a <- unique(sampleMetadata$disease)
b <- unique(sampleMetadata$disease_subtype)
c <- unique(sampleMetadata$study_condition)

sum(grepl(";", a)) # multiple values combined with semicolon
sum(grepl(";", b)) # multiple values combined with semicolon
sum(grepl(";", c)) 
```

There is one entry under `disease` column that multiple values are separated
by comma(`,`) instead of semicolon(`;`). Manually fix this.
```{r}
fix_ind <- grep("metastases_lung,metastases_nodes", sampleMetadata$disease)
sampleMetadata$disease[fix_ind]
sampleMetadata$disease[fix_ind] <- "melanoma;metastases_lung;metastases_nodes"
```

Merge `disease`, `disease_subtype`, and `study_condition` columns of 
the `sampleMetadata` table. 
```{r}
unique_disease <- unique(sampleMetadata$disease)
disease_all <- c() # collect all the diseases
for (i in seq_along(unique_disease)) {
    disease <- strsplit(unique_disease[i], split = ";") # split semicolon-separated values
    disease_all <- c(disease_all, unlist(disease))
}

unique_subtype <- unique(sampleMetadata$disease_subtype)
subtype_all <- c() # collect all the subtypes
for (i in seq_along(unique_subtype)) {
    subtype <- strsplit(unique_subtype[i], split = ";") # split semicolon-separated values
    subtype_all <- c(subtype_all, unlist(subtype))
}
    
## All the unique study_condition and disease_subtypes
all_conditions <- unique(c(disease_all, subtype_all,
                           sampleMetadata$study_condition)) 

## Format it as same as cmd_disease table
all_conditions_tb <- data.frame(Original.Abbreviation.Name = sort(all_conditions), 
                                Full.Name = NA,
                                Ontology.link = NA)
```

Next, we combine `all_conditions_tb`, `cmd_disease`, `disease_ontology`, 
and `mlRepo_disease` tables.
```{r}
cmd_all_conditions <- rbind(all_conditions_tb, cmd_disease) %>%
    rbind(., disease_ontology) %>%
    rbind(mlRepo_disease)

## Assign NA to all empty string for the convenient of downstream data cleaning
cmd_all_conditions[cmd_all_conditions == ""] <- NA
```

## Values need to be curated
We check whether all the existing curations are agreeing and which need
a further curation. First, we subset the curated values as `ont_complete` 
when they satisfy the following conditions: 1) Have `Ontology.link` value,
2) If curated multiple times, all curation results are same.    
 
We subset `cmd_all_conditions` with the unique original values that have the 
`Ontology.link` value. This table is named `ont_complete`. 

```{r}
names_all <- cmd_all_conditions$Original.Abbreviation.Name
duplicates <- names_all[which(duplicated(names_all))] 

check_duplicates <- c() # collect whether multiple `Ontology.link` assigned to one value are all identical
for (duplicate in duplicates) {
    ind <- which(ont_complete$Original.Abbreviation.Name == duplicate)
    res <- unique(ont_complete$Ontology.link[ind])
    check_duplicates <- c(check_duplicates, length(res))
}
all(check_duplicates == 1) # Make this as a sanity check point for reviewing curation discrepancy

ont_complete <- cmd_all_conditions %>% 
    filter(!is.na(Ontology.link)) %>%
    distinct(Original.Abbreviation.Name, .keep_all = TRUE) 
```

Any unique value without `Ontology.link` information is subjected for the 
further manual curation and exported to Google Sheet.
```{r}
# Filter rows where manual curation is needed
manual_curation <- cmd_all_conditions %>% 
    filter(!Original.Abbreviation.Name %in% ont_complete$Original.Abbreviation.Name) %>%
    add_column(Revision_Required = "") # explains observations that require clarification
```

```{r}
length(unique(cmd_all_conditions$Original.Abbreviation.Name))
nrow(ont_complete)
nrow(manual_curation)
```


## Curation
### Google Sheet for manual curation
Export the merged mapping table to Google Sheet for manual curation.
```{r create_gs, eval=FALSE}
gs4_create("cMD_curation")
```

```{r export_gs, eval=FALSE}
url <- "https://docs.google.com/spreadsheets/d/1QSbB_b1DkfqOc7q5eHE0IDHSiGqNUyTE8d4GzbSEzjM/edit?usp=sharing"
ss <- googledrive::as_id(url)
sheet_write(manual_curation, ss = ss, sheet = "disease_ontology")
```

### Save manually curated mapping table 
After the manual curation, update the target mapping table in GitHub. 
```{r import_gs}
url <- "https://docs.google.com/spreadsheets/d/1QSbB_b1DkfqOc7q5eHE0IDHSiGqNUyTE8d4GzbSEzjM/edit?usp=sharing"
ss <- googledrive::as_id(url)
manual_curated <- read_sheet(ss, sheet = "disease_ontology")
```

### Final curation file
```{r}
condition_map <- rbind(ont_complete, manual_curated[,c("Original.Abbreviation.Name",
                                                       "Full.Name",
                                                       "Ontology.link")])
condition_map <- rename(cMD_disease, Full.Name.Curated = Full.Name)
condition_map <- condition_map[order(condition_map$Original.Abbreviation.Name),]
```

```{r echo=FALSE, eval=FALSE}
dup_names <- condition_map$Full.Name.Curated[duplicated(tolower(condition_map$Full.Name.Curated))]
unique(dup_names)
```

Export the complete condition map to Google Sheet for manual inspection.
```{r eval=FALSE}
url <- "https://docs.google.com/spreadsheets/d/1QSbB_b1DkfqOc7q5eHE0IDHSiGqNUyTE8d4GzbSEzjM/edit?usp=sharing"
ss <- googledrive::as_id(url)
sheet_write(condition_map, ss = ss, sheet = "disease_ontology_all")
```

After manual fixes, import the final condition_ontology_map.
```{r}
condition_map <- read_sheet(ss, sheet = "disease_ontology_all")
```

Double-check whether the curation is correct. Any curated ontology terms
returned with `corret == FLASE` in `validation_tb` are reviewed.

```{r}
validation_tb <- data.frame(matrix(NA, nrow = nrow(condition_map), ncol = 4))
colnames(validation_tb) <- c("curated_onto_term", "curated_onto_id", 
                             "query_onto_term", "correct")

for (i in seq_len(nrow(condition_map))) {
    onto_term <- condition_map$curated_ontology_term[i]
    onto_id <- basename(condition_map$curated_ontology_term_id[i])
    qry <- OlsSearch(q = onto_id, exact = TRUE)
    qry <- olsSearch(qry)
    qdrf <- as(qry, "data.frame")
    
    validation_tb$curated_onto_term[i] <- onto_term
    validation_tb$curated_onto_id[i] <- onto_id
    validation_tb$query_onto_term[i] <- unique(qdrf$label)
    validation_tb$correct[i] <- identical(validation_tb$curated_onto_term[i],
                                          validation_tb$query_onto_term[i])
}

## 11 need-a-review entries
## 5 yet un-mapped + 6 with multiple mapped
validation_tb$correct[!validation_tb$correct,]
```

```{r update_the_condition_map, eval=FALSE}
colnames(condition_map) <- c("original_value",
                             "curated_ontology_term",
                             "curated_ontology_term_id")

## Save
write.csv(condition_map, "maps/cMD_condition_ontology.csv", row.names = FALSE)
```

### Update sampleMetadata
Assign disease ontology terms to sampleMetadata
```{r}
## Import the condition map
condition_map <- read.csv(file.path(proj_dir, "maps/cMD_condition_ontology.csv"), 
                          sep = ",", header = TRUE)
condition_map$curated_ontology_term_id <- basename(condition_map$curated_ontology_term_id)
```

```{r prepare_condition_mapping}
## A function to combine multiple values from multiple columns, separated by semicolon
combine_condition <- function(x) { # x is a character vector from each row (e.g. condition_tb[2374,])
    y <- strsplit(x[c("disease", "disease_subtype", "study_condition")], ";") %>% unlist
    y[!(y %in% condition_map$original_value)] <- "review_required" # leave a "missing_map" note if the value is not in the map
    z <- plyr::mapvalues(unlist(y), 
                         from = condition_map$original_value,
                         to = condition_map$curated_ontology_term,
                         warn_missing = FALSE)
    term <- unique(z[!is.na(z)], na.rm = TRUE) %>% paste(., collapse = ";")
    return(term)
}

## A function to assign ontology term id to combined values, separated by semicolon
combine_condition_ontology <- function(x) {
    y <- strsplit(x[c("disease", "disease_subtype", "study_condition")], ";") %>% unlist
    y[!(y %in% condition_map$original_value)] <- "review_required"
    z <- plyr::mapvalues(unlist(y), 
                         from = condition_map$original_value,
                         to = basename(condition_map$curated_ontology_term_id),
                         warn_missing = FALSE)
    onto <- unique(z[!is.na(z)], na.rm = TRUE) %>% paste(., collapse = ";")
    return(onto)
}
```

```{r}
## Subset to the condition/disease-related columns
condition_tb <- sampleMetadata[,c("curation_id", "disease", 
                                  "disease_subtype", "study_condition")]

## Keep only 'contol' in the study_condition column
control_ind <- which(condition_tb$study_condition == "control")
condition_tb$curated_study_condition <- NA
condition_tb$curated_study_condition_ontology_term_id <- NA
condition_tb$curated_study_condition[control_ind] <- "Study Control"
condition_tb$curated_study_condition_ontology_term_id[control_ind] <- "NCIT_C142703"

## Combine all disease-related information in one column
condition_tb$study_condition[control_ind] <- NA
curated_condition <- condition_tb %>%
    transmute(curation_id = curation_id,
              curated_study_condition = curated_study_condition,
              curated_study_condition_ontology_term_id = curated_study_condition_ontology_term_id,
              curated_disease = apply(., 1, combine_condition),
              curated_disease_ontology_term_id = apply(., 1, combine_condition_ontology))
head(curated_condition)
tail(curated_condition)
```

```{r eval=FALSE}
## Save
write.csv(curated_condition, 
          file = file.path(proj_dir, "data/curated_condition.csv"),
          row.names = FALSE)
```





# Age
## EDA on Age-related attributes
### `age` and `infant_age`
```{r}
age_tb <- sampleMetadata[,c("curation_id", "age", "infant_age", 
                            "gestational_age", "age_category")]

## Samples with both age and infant_age values 
both_ind <- which(!is.na(age_tb$age) & !is.na(age_tb$infant_age))
length(both_ind)

## Samples without either age or infant_age values 
no_ind <- which(is.na(age_tb$age) & is.na(age_tb$infant_age))
length(no_ind)
```

```{r sanity_check_infant_age}
## Samples with infant_age and age >=1
table(age_tb$age[both_ind]) 
ind_0yr <- intersect(both_ind, which(age_tb$age == 0))
ind_1yr <- intersect(both_ind, which(age_tb$age == 1))
ind_2yr <- intersect(both_ind, which(age_tb$age == 2))
ind_3yr <- intersect(both_ind, which(age_tb$age == 3))

## Double-check infant_age and age >=1 agree
all(age_tb$infant_age[ind_0yr] < 365*1 & age_tb$infant_age[ind_0yr] >= 0)
all(age_tb$infant_age[ind_1yr] < 365*2 & age_tb$infant_age[ind_1yr] >= 365)
all(age_tb$infant_age[ind_2yr] < 365*3 & age_tb$infant_age[ind_2yr] >= 365*2)
all(age_tb$infant_age[ind_3yr] < 365*4 & age_tb$infant_age[ind_3yr] >= 365*3)
```

There are 15 samples assigned with `age = 0` while there `infant_age` is larger
than 365. However, the final `curated_age` will use most detailed information
(i.e. `infant_age > 365` instead of `age = 0` for a given sample), this error
will be self-corrected in the process.

```{r sanity_check_age_disagreement} 
age_tb_0yr <- age_tb[ind_0yr,]
errored_ind <- which(!age_tb_0yr$infant_age < 365*1 & age_tb_0yr$infant_age >= 0)
age_tb_0yr[errored_ind,]
```

### `gestational_age`
No observations should exceed 43 weeks.
```{r sanity_check_gestational_age}
sum(sampleMetadata$gestational_age > 43, na.rm = TRUE) # should be 0
```

### `age_category`
Except one, all the samples in cMD has age-related information as a specific
numeric value and/or age category. (Check whether this NA entry can be updated.)
```{r sanity_check_age_category}
table(age_tb$age_category[no_ind], useNA = "ifany") # age_category of those samples without any other age-related info
table(age_tb$age_category[-no_ind], useNA = "ifany")

na_ind <- which(is.na(age_tb$age_category))
sampleMetadata[na_ind, 1:15]
```

## Curation
### `age` and `infant_age`
* Curation schema we applied on age-related attributes are
    - Use `infant_age` if both `age` and `infant_age` are available
    - When both `age` and `infant_age` are not available, use `age_category`
    - If `age` or `infant_age` is available, assign age_group based on them 
    instead of using `age_category`
    
```{r}
curated_infant_age <- age_tb %>%
    dplyr::filter(!is.na(infant_age)) %>%
    dplyr::transmute(curation_id = curation_id,
                     original_age_source = "infant_age",
                     original_age_value = infant_age,
                     original_age_unit = "day",
                     curated_age_years = infant_age/365,
                     curated_age_min = infant_age/365,
                     curated_age_max = infant_age/365,
                     curated_age_group = NA,
                     curated_age_group_ontology_term_id = NA)

curated_age <- age_tb %>%
    dplyr::filter(is.na(infant_age) & !is.na(age)) %>% 
    dplyr::transmute(curation_id = curation_id, 
                     original_age_source = "age",
                     original_age_value = age,
                     original_age_unit = "year",
                     curated_age_years = age,
                     curated_age_min = age,
                     curated_age_max = age,
                     curated_age_group = NA,
                     curated_age_group_ontology_term_id = NA)

# no_age_info <- age_tb %>%
#     dplyr::filter(is.na(age) & is.na(infant_age)) %>%
#     dplyr::transmute(curation_id = curation_id, 
#                      original_age_source = "age",
#                      original_age_value = age,
#                      original_age_unit = "year",
#                      curated_age = age,
#                      curated_age_min = age,
#                      curated_age_max = age,
#                      curated_age_group = NA,
#                      curated_age_group_ontology = NA)    
```


### `age_category`
```{r age_category}
## If `age_category` is the only available age-related metadata, use it as
## an input for `curated_age_group`. Unless, curate `curated_age_group` is
## calculated based on the actual numeric variable using ontology.
age_group_only <- age_tb %>%
    dplyr::filter(is.na(age) & is.na(infant_age)) %>%
    dplyr::transmute(curation_id = curation_id, 
                     age_category = age_category, # keep this for mapping
                     original_age_source = "age_category",
                     original_age_value = NA,
                     original_age_unit = NA,
                     curated_age_years = NA,
                     curated_age_min = NA,
                     curated_age_max = NA,
                     curated_age_group = NA,
                     curated_age_group_ontology_term_id = NA)  

age_group_need_curation <- age_tb %>%   # curated age fields are filled with numeric value
    dplyr::filter(!is.na(age) | !is.na(infant_age)) %>%
    dplyr::transmute(curation_id = curation_id,
                     curated_age_group = NA,
                     curated_age_group_ontology_term_id = NA)
```

Original curation on `age_category` is erroneous and not following proper
onthology definition. (e.g. infant, 19 for schoolage)

```{r EDA_age_category}
## Age ranges for infant category (unit in 'day')
age_tb %>%
    filter(age_category == "newborn") %>%
    filter(!is.na(infant_age)) %>%
    summarize(infant_age_min = min(infant_age), 
              infant_age_max = max(infant_age))

## Definition of `age_category` used in cMD sampleMetadata
age_categories <- unique(age_tb$age_category)
age_category_def <- data.frame(original_value = age_categories,
                               original_value_min = NA,
                               original_value_max = NA)
for (i in seq_along(age_categories)) {
    res <- age_tb %>%
        filter(age_category == age_categories[i]) %>%
        filter(!is.na(age))
    age_category_def[i, 2] <- min(res$age)
    age_category_def[i, 3] <- max(res$age)
}

## The original `age_category` definition (not mutually exclusive/ wrong)
age_category_def
```

```{r export_gs_sheet_for_age, eval=FALSE, echo=FALSE}
age_group_ontology <- data.frame(original_value = NA,
                                 curated_age_group = NA,
                                 curated_age_group_ontology_term_id = NA)
sheet_write(age_group_ontology, ss = ss, sheet = "age_group_ontology")
```

```{r eval=FALSE}
## Import the age-mapping table
age_group_map <- read_sheet(ss, sheet = "age_group_ontology")
age_group_map

## Save
write.csv(age_group_map, "maps/cMD_age_ontology.csv", row.names = FALSE)
```


### Update sampleMetadata
```{r load_age_map, echo=FALSE}
age_group_map <- read.table("maps/cMD_age_ontology.csv", sep = ",", header = TRUE)
```

```{r age_group_for_no_numeric_age}
## age_group ontology
curated_age_group <- plyr::mapvalues(x = age_group_only$age_category, 
                                     from = age_group_map$original_value, 
                                     to = age_group_map$curated_age_group, 
                                     warn_missing = TRUE)

## age_group min
curated_age_min <- plyr::mapvalues(x = age_group_only$age_category, 
                                   from = age_group_map$original_value, 
                                   to = age_group_map$curated_age_min, 
                                   warn_missing = TRUE)

## age_group max
curated_age_max <- plyr::mapvalues(x = age_group_only$age_category, 
                                   from = age_group_map$original_value, 
                                   to = age_group_map$curated_age_max, 
                                   warn_missing = TRUE)

## Add the curated values
age_group_only$curated_age_group <- curated_age_group
age_group_only$curated_age_min <- curated_age_min
age_group_only$curated_age_max <- curated_age_max

age_group_only <- age_group_only[,-which(colnames(age_group_only) == "age_category")]
```

```{r age_group_for_numeric_age}
curated_numeric_age <- rbind(curated_infant_age, curated_age) 

## Assign age_group based on the numeric age info
res_pool <- age_group_map$curated_age_group[order(age_group_map$curated_age_min)]
res_ind <- findInterval(curated_numeric_age$curated_age_years, vec = sort(age_group_map$curated_age_min))
curated_numeric_age$curated_age_group <- res_pool[res_ind]

curated_age_all <- rbind(curated_numeric_age, age_group_only)
nrow(curated_age_all) == nrow(age_tb) ## Check all 22,588 samples are there

## Assign ontology to all
age_onto <- plyr::mapvalues(x = curated_age_all$curated_age_group, 
                            from = age_group_map$curated_age_group, 
                            to = basename(age_group_map$curated_age_group_ontology_term_id), 
                            warn_missing = TRUE)
curated_age_all$curated_age_group_ontology_term_id <- age_onto
```

```{r eval=FALSE}
## Save
curated_age_all <- curated_age_all[order(curated_age_all$curation_id),]
write.csv(curated_age_all, 
          file = file.path(proj_dir, "data/curated_age.csv"),
          row.names = FALSE)
```




# Bodysite
## Curation
A part of bodysite curation is available in [body-site-ontology.csv](https://github.com/waldronlab/curatedMetagenomicDataCuration/blob/master/inst/extdata/body-site-ontology.csv) under curatedMetagenomicDataCuration GitHub repository.

This curation file is confirmed to contain all the values from sampleMetadta
table while there are some discrepant, missing, and wrong values. For the 
further curation, this table is exported as Google Sheet.

```{r eval=FALSE}
file_url <- "https://raw.githubusercontent.com/waldronlab/curatedMetagenomicDataCuration/master/inst/extdata/body-site-ontology.csv"
cMD_bodysite <- read.csv(file_url, sep = ",", header = TRUE)
colnames(cMD_bodysite) <- c("original_value",
                            "curated_ontology_term",
                            "curated_ontology_term_id")
sheet_write(cMD_bodysite, ss = ss, sheet = "bodysite_ontology")

## Confirm that the manual curation table contains all the values in sampleMetadata
bodysites <- unique(c(sampleMetadata$body_site,
                      sampleMetadata$body_subsite))
setdiff(bodysites, cMD_bodysite$original_value)
```

Manual curated file is imported.
```{r}
## Import the curated bodysite-mapping table
url <- "https://docs.google.com/spreadsheets/d/1QSbB_b1DkfqOc7q5eHE0IDHSiGqNUyTE8d4GzbSEzjM/edit?usp=sharing"
ss <- googledrive::as_id(url)
bodysite_map <- read_sheet(ss, sheet = "bodysite_ontology")
bodysite_map
```

Double-check whether the curation is correct. Any curated ontology terms
returned with `corret == FLASE` in `validation_tb` are reviewed.

```{r}
validation_tb <- data.frame(matrix(NA, nrow = nrow(bodysite_map), ncol = 4))
colnames(validation_tb) <- c("curated_onto_term", "curated_onto_id", 
                             "query_onto_term", "correct")

for (i in seq_len(nrow(bodysite_map))) {
    onto_term <- bodysite_map$curated_ontology_term[i]
    onto_id <- basename(bodysite_map$curated_ontology_term_id[i])
    qry <- OlsSearch(q = onto_id, exact = TRUE)
    qry <- olsSearch(qry)
    qdrf <- as(qry, "data.frame")
    
    validation_tb$curated_onto_term[i] <- onto_term
    validation_tb$curated_onto_id[i] <- onto_id
    validation_tb$query_onto_term[i] <- unique(qdrf$label)
    validation_tb$correct[i] <- identical(validation_tb$curated_onto_term[i],
                                       validation_tb$query_onto_term[i])
}
```

```{r eval=FALSE}
sheet_write(bodysite_map, ss = ss, sheet = "bodysite_ontology")

## Save
write.csv(bodysite_map, "maps/cMD_bodysite_ontology.csv", row.names = FALSE)
```

### Update sampleMetadata
Curate the bodysite-related metadata in the sampleMetadata table. Because less
than 10% of samples contain `body_subsite` information while all the samples
have `body_site` information, I keep both columns in curated format. Also, I 
removed any `body_subsite` value that is identical to `body_site`.

```{r}
bodysite_tb <- sampleMetadata[,c("curation_id", "body_site", "body_subsite")]
curated_bodysite <- bodysite_tb %>%
    transmute(curation_id = curation_id,
              curated_body_site = mapvalues(x = bodysite_tb$body_site,
                                            from = bodysite_map$original_value,
                                            to = bodysite_map$curated_ontology_term,
                                            warn_missing = TRUE),
              curated_body_site_ontology_term_id = mapvalues(x = bodysite_tb$body_site,
                                                             from = bodysite_map$original_value,
                                                             to = basename(bodysite_map$curated_ontology_term_id),
                                                             warn_missing = TRUE),
              curated_body_subsite = mapvalues(x = bodysite_tb$body_subsite,
                                               from = bodysite_map$original_value,
                                               to = bodysite_map$curated_ontology_term,
                                               warn_missing = TRUE),
              curated_body_subsite_ontology_term_id = mapvalues(x = bodysite_tb$body_subsite,
                                                                from = bodysite_map$original_value,
                                                                to = basename(bodysite_map$curated_ontology_term_id),
                                                                warn_missing = TRUE))

## Remove body_subsite that is identical to body_site
redundant_ind <- which(curated_bodysite$curated_body_site == curated_bodysite$curated_body_subsite)
curated_bodysite[redundant_ind, c("curated_body_subsite", "curated_body_subsite_ontology_term_id")] <- NA
```

```{r eval=FALSE}
## Save
write.csv(curated_bodysite,
          file = "data/curated_bodysite.csv",
          row.names = FALSE)
```
