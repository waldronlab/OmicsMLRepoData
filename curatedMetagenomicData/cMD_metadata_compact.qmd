---
title: "Merge cMD metadata for AI/ML"
author: "Sehyun Oh"
date: "`r format(Sys.time(), '%B %d, %Y')`"
format:
    html:
        fontsize: 14px
        toc: true
        top-depth: 3
abstract: "Prepare U24 Supplement: AI/ML-ready"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, 
                      collapse = TRUE)
```

# Setup
```{r}
library(curatedMetagenomicData)
library(OmicsMLRepoData)
```

`sampleMetadataCompact.csv` is created using the script in 
`cMD_metadata_compact.R`, which is currently in progress. 
```{r eval=FALSE}
## Done by Sehyun
source("~/Packages/OmicsMLRepoData/curatedMetagenomicData/cMD_metadata_compact.R")
```

The `uncurated` column of `sampleMetadataCompact.csv` table contains all 
the values makred as `FALSE` in the `ver_0.99.0` column in the 
`cMD_metadata_export_version.csv` table. For each column, the column name 
and the value is separated by `:` and different columns are separated by `;`.

For now, we are ignoring these uncurated variables. Some of these uncurated
variables will be exposed in the future releases.

```{r}
dir <- system.file("extdata", package = "OmicsMLRepoData")
all <- read.table(file.path(dir, "cMD_sampleMetadataCompact.csv"), 
                  sep = ",", header = TRUE)
dataset <- all[,-which(colnames(all) %in% "uncurated")]
```

# Overview
The number of unique attributes for each metadata variable. I checked this 
to get the sense of how complex/(potentially) redundant a given variable is. 
```{r}
apply(dataset, 2, function(x) {length(unique(x))})
```

# Helper functions
Check the sample-level completeness of the metadata using `perComp` function.
Provide the name of the variable through `var` argument. Currently, 
`db = "cMD"` is only supported. 

```{r}
perComp(db = "cMD", var = "PMID")
```

Check the PMID of the dataset with the specific metadata value. Column 
name of the metadata table is provided through `key` argument and the 
actual value should be provided through `value` argument. For example, 
you can extract all the PMID with the `study_condition` is `melanoma` using
the below command. This can be useful when you need to find the original
paper to get more information on the specific metadatda.

```{r}
GetPMID(db = "cMD", key = "study_condition", value = "melanoma")
```

# Variables of our interest
```{r}
## ID or continuous variables. 
## ID variables for subset and continuous variables for plotting?
contVars <- c(
    "study_name",
    "sample_id",
    "subject_id",
    "age",
    "infant_age",
    "PMID", # 90.0% available
    "NCBI_accession",
    "BMI",
    "treatment", # 23.2% available >>>>>>>>>>> Need harmonization
    "days_from_first_collection",
    "birth_weight",
    "gestational_age",
    "disease_subtype", # 13.6% complete >>>>>>>>>>> Need harmonization
    "population", # 9.2% complete >>>>>>>>>>>>>>>>>>>> Need harmonization
    "cholesterol"
)

## Variable for summary
myVars <- c(
    "body_site", # complete
    "antibiotics_current_use", # 55.8% available
    "study_condition", # 99.8% available >>>>>>>>>>> Need harmonization
    "disease", # complete >>>>>>>>>>>>>>>>>>>>> Need harmonization
    # "age", # 73.9% available
    # "infant_age", # 14.1% available
    "age_category", # complete
    "gender", # 84.7% available
    "country", # complete: country code is based on `iso3c`
    "non_westernized", # complete
    "sequencing_platform", # complete
    "pregnant" # 7.4% available
    )

## Categorical variables
catVars <- c(
    "body_site", # complete
    "antibiotics_current_use", # 55.8% available
    "study_condition", # 99.8% available >>>>>>>>>>> Need harmonization
    "disease", # complete >>>>>>>>>>>>>>>>>>>>> Need harmonization
    "age_category", # complete
    "gender", # 84.7% available
    "country", # complete: country code is based on `iso3c`
    "non_westernized", # complete
    "sequencing_platform", # complete
    "pregnant" # 7.4% available
    )
```

## Summary table of the target variables
```{r}
apply(dataset[,myVars], 2, table, useNA = "always")
```


# Export
Export tables for manual curation. Ontology matching will be done in 
the [Google Sheet](https://docs.google.com/spreadsheets/d/1VazibASea-_QptyQy2MZcWoR-Qm_-Nztaoc52YZDQ3g/edit?usp=sharing). 

## study_condition
```{r}
study_condition_tb <- stack(table(dataset$study_condition))
write.csv(study_condition_tb, "study_condition.csv")
```

## disease
```{r}
disease_tb <- stack(table(dataset$disease))
write.csv(disease_tb, "disease.csv")
```





# Ontology
"ACVD" stands for "Atherosclerotic cardiovascular disease". We can search 
the ontology using `rols` package, if we need to automate it at some levels. 

```{r}
library(rols)
OlsSearch(q = "Atherosclerotic cardiovascular disease", exact = TRUE)

qry <- OlsSearch(q = "Atherosclerotic cardiovascular disease", exact = TRUE)
qry <- olsSearch(qry)
qtrms <- as(qry, "Terms")
str(qdrf <- as(qry, "data.frame"))
```

```{r}
cMD_study_conditions <- unique(dataset$study_condition)
res_all <- c()

for (condition in cMD_study_conditions) {
    qry <- OlsSearch(q = condition, exact = TRUE, ontology = "NCIT")
    res_all <- c(res_all, qry@numFound)
}

df <- data.frame(study_condition = cMD_study_conditions,
                 response = res_all)
head(df)
```




```{r Country, echo=FALSE, eval=FALSE}
## Country
## cMD sampleMetadata's country code is based on `iso3c`.
cMD <- names(table(dataset$country))

## I can check cowc format of the country names
# cowc <- countrycode(cowcodes, origin = "iso3c", destination = "cowc")
# country_df <- data.frame(cMD = cowcodes, cowc = cowc)

country <- countrycode(cowcodes, origin = "iso3c", destination = "country.name")
country_df <- data.frame(iso3c = cMD, country = country)
head(country_df)
```

```{r echo=FALSE, eval=FALSE}
library(tableone)
z <- CreateTableOne(vars = myVars,
                    data = dataset, 
                    strata = "study_name", 
                    factorVars = catVars,
                    includeNA = TRUE) %>%
    print(., showAllLevels = TRUE)
```