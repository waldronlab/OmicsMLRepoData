---
title: "Harmonize study_condition information in cMD sample metadata"
author:
  - Sehyun Oh
  - Kai Gravel-Pucillo
date: "`r format(Sys.time(), '%B %d, %Y')`"
format:
    html:
        fontsize: 14pxs
        toc: true
        top-depth: 3
abstract: "Prepare U24 Supplement: AI/ML-ready"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                    warning = FALSE,
                    message = FALSE,
                    collapse = TRUE,
                    eval = TRUE)
```

# Overview

This .qmd file demonstrates a workflow for curating and harmonizing study 
condition data with the curatedMetagenomicData package.
This file curates information from the original study_condition, disease, and 
disease_subtype columns to produce the curated control, target_phenotype, and
disease columns.

# Setup
## Load Packages

```{r load}
suppressPackageStartupMessages({
  library(curatedMetagenomicData)
  library(tidyverse)
  library(googlesheets4)
  library(gsheet)
  library(rols)
  library(AMR)
})
```

## Setup for Curation

We will first add a `curation_id` consisting of study name and sample ID 
(`study_name:sample_id`) to avoid confusion due to duplicated samples. 
Then we will set up a Google Sheet to export our mapping table to.

```{r curation_setup}
# Add curation ID
sampleMetadata$curation_id <- paste(sampleMetadata$study_name, sampleMetadata$sample_id, sep = ":")

# Setup google sheets link to mapping table
url <- "https://docs.google.com/spreadsheets/d/1QSbB_b1DkfqOc7q5eHE0IDHSiGqNUyTE8d4GzbSEzjM/edit?usp=sharing"

ss <- googledrive::as_id(url)
```

# Exploratory Data Analysis

## Manual Data Corrections

Next, we will make some manual corrections to the data.
It was found that a comma delimiter was used in palce of a semicolon on some 
entries in the disease column. For accessibility we will replace these commas 
with semicolons:
```{r}
# Fixing the accidental comma delimiters
for (d in 1:length(sampleMetadata$disease)){
  sampleMetadata$disease[d] <- gsub(",", ";", sampleMetadata$disease[d])
}
# Create dataframe of relevant columns 
disease_data <- sampleMetadata[,c("curation_id","study_name","study_condition","disease","disease_subtype")]
```

It was also found that one entry from the study "MetaCardis_2020_a" had an "MA"
value entered in the `disease` column in place of the value "MS" due to a 
curation error. We will adjust for this in the ontology map to replace the value
with the correct ontology term "Metabolic Syndrome".


# Data Curation

## Validation

Once the maps have been manually curated, we can double-check that they are correct before saving them to GitHub.
Any curated ontology terms returned with `correct == FALSE` in `validation_tb` are reviewed.

```{r validate_map, eval=FALSE}
# import study condition ontology map for validation
study_condition_map <- read_sheet(ss, sheet = "study_condition_ontology")

# create validation table for curation statuses
sc_validation_tb <- data.frame(matrix(NA, nrow = nrow(study_condition_map), ncol = 4))
colnames(sc_validation_tb) <- c("curated_onto_term", "curated_onto_id", 
                             "query_onto_term", "correct")

# check each ontology term and indicate incorrect values
for (i in seq_len(nrow(study_condition_map))) {
    onto_term <- study_condition_map$curated_ontology_term[i]
    onto_id <- basename(study_condition_map$curated_ontology_term_id_link[i])
    qry <- OlsSearch(q = onto_id, exact = TRUE)
    qry <- olsSearch(qry)
    qdrf <- as(qry, "data.frame")
    
    sc_validation_tb$curated_onto_term[i] <- onto_term
    sc_validation_tb$curated_onto_id[i] <- onto_id
    sc_validation_tb$query_onto_term[i] <- unique(qdrf$label)
    sc_validation_tb$correct[i] <- identical(sc_validation_tb$curated_onto_term[i], sc_validation_tb$query_onto_term[i])
}

# get all incorrect rows for review
sc_validation_tb[!sc_validation_tb$correct,]
```

Upon reviewing the 7 rows flagged by the validation process, the accuracy of all
ontology terms has been verified.

## Storage

Once everything has been reviewed and the Google Sheets maps have been updated as needed, we can save the maps to GitHub.

```{r save_maps_to_github, eval=FALSE}
# load map from Google Sheets
study_condition_ontology <- read_sheet(ss, sheet = "study_condition_ontology")

# save map to GitHub
write.csv(study_condition_ontology,
          file = file.path(proj_dir, "maps/cMD_study_condition_ontology.csv"),
          row.names = FALSE)

# load map from Google Sheets
target_phenotype <- read_sheet(ss, sheet = "target_phenotype_map")

# save map to GitHub
write.csv(target_phenotype,
          file = file.path(proj_dir, "maps/cMD_target_phenotype_map.csv"),
          row.names = FALSE)
```

# Mapping

## Import Maps

To access the necessary disease ontology terms we will load the 
`disease_ontology_map`. To access the manually-curated target phenotype(s) 
associated with each study we will load the `target_phenotype_map`.

```{r import_maps, eval=FALSE}
# import the disease ontology map
disease_ontology_map <- read.csv(file = file.path(proj_dir, "maps/cMD_study_condition_ontology.csv"),
                          sep = ",", header = TRUE)

# import the target phenotype map
target_phenotype_map <- read.csv(file = file.path(proj_dir, "maps/cMD_target_phenotype_map.csv"),
                          sep = ",", header = TRUE)
```

## Curating "control" Column

Using the "study_condition" column as a guide, identify whether each sample was part 
of the "control" group or the "case" group for its corresponding study. Samples that 
were not utilized in the study receive the label "Not Used".
```{r}
# Label patient data to indicate control or treatment group
for (i in 1:nrow(disease_data)){
  if (grepl("control", disease_data$study_condition[i])){
    disease_data$control[i] <- "Study Control"
    disease_data$control_ontology_term_id[i] <- "NCIT_C142703" # http://purl.obolibrary.org/obo/NCIT_C142703
  }
  else if (is.na(disease_data$study_condition[i])){
    disease_data$control[i] <- "Not Used"
    disease_data$control_ontology_term_id[i] <- "NCIT_C69062" # http://purl.obolibrary.org/obo/NCIT_C69062
  }
  else{
    disease_data$control[i] <- "Case"   
    disease_data$control_ontology_term_id[i] <- "NCIT_C49152" # http://purl.obolibrary.org/obo/NCIT_C49152
  }
}
```

Now we can clean up the "study_condition" column by replacing any instances of the term 
"control" with an "NA" value, which will prevent redundant data when we combine this 
column with the "disease" column.

```{r}
# Replace "control" values with NA in study_condition column
for (d in 1:length(disease_data$study_condition)){
  disease_data$study_condition[d] <- gsub("control", NA, disease_data$study_condition[d])
}
```


## Curating "disease" Column

Some of the information between columns demonstrates significant redundancy. 
Specifically the "disease" column features many redundant values from the 
"study_condition" column. 

For some of the values in the study_condition column there is only one 
corresponding value in the disease column, however this does not necessarily 
mean that there is only one corresponding value in the study_condition column 
for that single disease column value. For example, "pre-hypertension" in the 
study_condition column only has one corresponding value in the disease column; 
"hypertension". However, "hypertension" has three corresponding values in the 
study_condition column; "pre-hypertension", "hypertension", and "control".

This indicates that the "study_condition" column is a more specific 
classification in this instance, and the delineation between these three groups 
should be reflected in the final combined column. 

Next, we can create a new "condensed" column that preserves the values from 
both columns when values are different, and condenses identical values:
```{R}
# Append study_condition value to disease value if it is not redundant
for (i in 1:nrow(disease_data)){
  if (is.na(disease_data$study_condition[i]) | 
      (grepl(disease_data$study_condition[i], disease_data$disease[i], 
             fixed=TRUE))){
    disease_data$condensed[i] <- disease_data$disease[i]
  }
  else{
    disease_data$condensed[i] <- paste(disease_data$disease[i], 
                                    disease_data$study_condition[i], sep=";")   
  }
}
```

We can then append the non-redundant "disease_subtype" values onto the 
"condensed" column values in a new "merged" column:
```{R}
# Append disease_subtype information if it is not redundant
for (i in 1:nrow(disease_data)){
  if (is.na(disease_data$disease_subtype[i]) | 
      (grepl(disease_data$disease_subtype[i], disease_data$condensed[i], fixed=TRUE))){
    disease_data$merged[i] <- disease_data$condensed[i]
  }
  else{
    disease_data$merged[i] <- paste(disease_data$condensed[i], 
                                    disease_data$disease_subtype[i], sep=";")   
  }
}
```

Our "merged" column now contains all data from the three disease data columns, 
with unique attributes delimited by the ";" symbol, which will allow us to 
easily parse this column's data in the future for whichever specific values we 
need to access.

Finally, we will update the terminology in the merged column to create a new
curated disease column, using the curated disease_ontology_map:
```{r}
# Iterate through merged column values
for (x in 1:length(disease_data$merged)){
  # Create a list of terms in the value
  original_terms <- as.list(unlist(strsplit(disease_data$merged[x], ";")))
  new_terms <- list()
  new_term_ids <- list()
  # Search for replacement terms in the ontology map
  for (i in 1:length(original_terms)){
    new_term <- disease_ontology_map$curated_ontology_term[grep(paste("^",original_terms[i],"$",sep=""), disease_ontology_map$original_value, fixed=F)]
    new_term_id <- disease_ontology_map$curated_ontology_term_id[grep(paste("^",original_terms[i],"$",sep=""), disease_ontology_map$original_value, fixed=F)]
    # Append replacement term to new list if not already included
    if(length(new_term)!=0){
      if(!(new_term %in% new_terms)){
        new_terms <- append(new_terms, new_term)
        new_term_ids <- append(new_term_ids, new_term_id)
      }
    }
  # Concatenate new lists on ";" delimiter to create curated value
  disease_data$curated_disease[x] <- paste(new_terms, collapse= ";")
  disease_data$curated_disease_ontology_term_id[x] <- paste(new_term_ids, collapse= ";")
  }
}
```


## Curating "target_phenotype" Column

Using the study names and the target_phenotype_map, we can create columns for 
target_phenotype data:
```{r}
# Iterate through all data in sampleMetadata to create target_phenotype columns
for (i in 1:length(sampleMetadata$study_name)){
  disease_data$curated_target_phenotype[i] <- target_phenotype_map$target_phenotype[which(target_phenotype_map$study_name == sampleMetadata$study_name[1])]
  disease_data$curated_target_phenotype_ontology_term_id[i] <- target_phenotype_map$target_phenotype_term_id[which(target_phenotype_map$study_name == sampleMetadata$study_name[i])]
}
```


## Curated Table Creation

Then we will create our table of curated study condition data, including 
original values, curated values, and curated ontology term ids.
```{r}
# Create a dataframe of the relevant columns
curated_study_condition <- data.frame(sampleMetadata[,c("curation_id", "study_condition", "disease", "disease_subtype")], disease_data[,c("control", "control_ontology_term_id","curated_target_phenotype", "curated_target_phenotype_ontology_term_id", "curated_disease", "curated_disease_ontology_term_id")])

# Rename the columns for accuracy & specificity
colnames(curated_study_condition)[2:6] <- c("original_study_condition_value", "original_disease_value", "original_disease_subtype_value", "curated_control", "curated_control_ontology_term_id")
```


## Export

Finally, we will export our completed table to GitHub.

```{r export_curated_table, eval=FALSE}
# export to GitHub
write.csv(curated_study_condition, 
          file = file.path(proj_dir, "data/curated_study_condition.csv"),
          row.names = FALSE)
```
